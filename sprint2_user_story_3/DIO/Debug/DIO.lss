
DIO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000834  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000834  000008c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  00800062  00800062  000008ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000008fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00000938  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001002  00000000  00000000  00000ae0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009c8  00000000  00000000  00001ae2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ddb  00000000  00000000  000024aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004d8  00000000  00000000  00003288  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000902  00000000  00000000  00003760  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008e5  00000000  00000000  00004062  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00004947  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 56 03 	jmp	0x6ac	; 0x6ac <__vector_10>
  2c:	0c 94 49 00 	jmp	0x92	; 0x92 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e3       	ldi	r30, 0x34	; 52
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 37       	cpi	r26, 0x76	; 118
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 b4 02 	call	0x568	; 0x568 <main>
  8a:	0c 94 18 04 	jmp	0x830	; 0x830 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__vector_11>:
/********************************************* External Functions *************************************/
extern void Traffic_light_delay_ISR(); 

/***************************************** Interrupt service rotuine *********************************/
/* TIMER0 OVF interrupt service routine */
ISR(TIMER0_OVF_vect){
  92:	1f 92       	push	r1
  94:	0f 92       	push	r0
  96:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
  9a:	0f 92       	push	r0
  9c:	11 24       	eor	r1, r1
  9e:	cf 93       	push	r28
  a0:	df 93       	push	r29
  a2:	cd b7       	in	r28, 0x3d	; 61
  a4:	de b7       	in	r29, 0x3e	; 62
		 
}
  a6:	00 00       	nop
  a8:	df 91       	pop	r29
  aa:	cf 91       	pop	r28
  ac:	0f 90       	pop	r0
  ae:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
  b2:	0f 90       	pop	r0
  b4:	1f 90       	pop	r1
  b6:	18 95       	reti

000000b8 <Tasks_init>:
Function Parameters  : N/A

Function Return      : N/A

*******************************************************************************/
void Tasks_init(){
  b8:	cf 93       	push	r28
  ba:	df 93       	push	r29
  bc:	cd b7       	in	r28, 0x3d	; 61
  be:	de b7       	in	r29, 0x3e	; 62
	 DIO_SetPinDirection(LED1_PIN_NUM,OUTPUT);
  c0:	61 e0       	ldi	r22, 0x01	; 1
  c2:	8d e0       	ldi	r24, 0x0D	; 13
  c4:	0e 94 af 01 	call	0x35e	; 0x35e <DIO_SetPinDirection>
	 DIO_SetPinDirection(LED2_PIN_NUM,OUTPUT);
  c8:	61 e0       	ldi	r22, 0x01	; 1
  ca:	8e e0       	ldi	r24, 0x0E	; 14
  cc:	0e 94 af 01 	call	0x35e	; 0x35e <DIO_SetPinDirection>
	 DIO_SetPinDirection(LED3_PIN_NUM,OUTPUT);
  d0:	61 e0       	ldi	r22, 0x01	; 1
  d2:	8f e0       	ldi	r24, 0x0F	; 15
  d4:	0e 94 af 01 	call	0x35e	; 0x35e <DIO_SetPinDirection>
	 TIMER0_OCR_init(TICKS_FOR_1MS);
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	0e 94 c8 03 	call	0x790	; 0x790 <TIMER0_OCR_init>
}
  e0:	00 00       	nop
  e2:	df 91       	pop	r29
  e4:	cf 91       	pop	r28
  e6:	08 95       	ret

000000e8 <Task_BLINK_LED1>:
Function Parameters  : N/A 

Function Return      : N/A

*******************************************************************************/
volatile void Task_BLINK_LED1(){
  e8:	cf 93       	push	r28
  ea:	df 93       	push	r29
  ec:	cd b7       	in	r28, 0x3d	; 61
  ee:	de b7       	in	r29, 0x3e	; 62
	if(Call_Back_Flag == TRUE){
  f0:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <Call_Back_Flag>
  f4:	81 30       	cpi	r24, 0x01	; 1
  f6:	51 f4       	brne	.+20     	; 0x10c <Task_BLINK_LED1+0x24>
		Toggle_Bit(LED1_PORT,5);
  f8:	88 e3       	ldi	r24, 0x38	; 56
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	28 e3       	ldi	r18, 0x38	; 56
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	f9 01       	movw	r30, r18
 102:	30 81       	ld	r19, Z
 104:	20 e2       	ldi	r18, 0x20	; 32
 106:	23 27       	eor	r18, r19
 108:	fc 01       	movw	r30, r24
 10a:	20 83       	st	Z, r18
	}
}
 10c:	00 00       	nop
 10e:	df 91       	pop	r29
 110:	cf 91       	pop	r28
 112:	08 95       	ret

00000114 <Task_BLINK_LED2>:
Function Parameters  : N/A

Function Return      : N/A

*******************************************************************************/
volatile void volatile Task_BLINK_LED2(){
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	cd b7       	in	r28, 0x3d	; 61
 11a:	de b7       	in	r29, 0x3e	; 62
	if(Call_Back_Flag == TRUE){	
 11c:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <Call_Back_Flag>
 120:	81 30       	cpi	r24, 0x01	; 1
 122:	51 f4       	brne	.+20     	; 0x138 <Task_BLINK_LED2+0x24>
		Toggle_Bit(LED2_PORT,6);
 124:	88 e3       	ldi	r24, 0x38	; 56
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	28 e3       	ldi	r18, 0x38	; 56
 12a:	30 e0       	ldi	r19, 0x00	; 0
 12c:	f9 01       	movw	r30, r18
 12e:	30 81       	ld	r19, Z
 130:	20 e4       	ldi	r18, 0x40	; 64
 132:	23 27       	eor	r18, r19
 134:	fc 01       	movw	r30, r24
 136:	20 83       	st	Z, r18
	}
}
 138:	00 00       	nop
 13a:	df 91       	pop	r29
 13c:	cf 91       	pop	r28
 13e:	08 95       	ret

00000140 <Task_BLINK_LED3>:
Function Parameters  : N/A

Function Return      : N/A

*******************************************************************************/
volatile void Task_BLINK_LED3(){
 140:	cf 93       	push	r28
 142:	df 93       	push	r29
 144:	cd b7       	in	r28, 0x3d	; 61
 146:	de b7       	in	r29, 0x3e	; 62
  if(Call_Back_Flag == TRUE){	
 148:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <Call_Back_Flag>
 14c:	81 30       	cpi	r24, 0x01	; 1
 14e:	51 f4       	brne	.+20     	; 0x164 <Task_BLINK_LED3+0x24>
	Toggle_Bit(LED3_PORT,7);
 150:	88 e3       	ldi	r24, 0x38	; 56
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	28 e3       	ldi	r18, 0x38	; 56
 156:	30 e0       	ldi	r19, 0x00	; 0
 158:	f9 01       	movw	r30, r18
 15a:	30 81       	ld	r19, Z
 15c:	20 e8       	ldi	r18, 0x80	; 128
 15e:	23 27       	eor	r18, r19
 160:	fc 01       	movw	r30, r24
 162:	20 83       	st	Z, r18
  }
 164:	00 00       	nop
 166:	df 91       	pop	r29
 168:	cf 91       	pop	r28
 16a:	08 95       	ret

0000016c <Schedular_init>:
					   task_priodicity : no of second of each task to run
						
Function Return      : N/A

*******************************************************************************/
void Schedular_init(void (*Added_Fun_Name)(void),uint8 fun_priority,uint16 task_periodicity){
 16c:	cf 93       	push	r28
 16e:	df 93       	push	r29
 170:	00 d0       	rcall	.+0      	; 0x172 <Schedular_init+0x6>
 172:	00 d0       	rcall	.+0      	; 0x174 <Schedular_init+0x8>
 174:	1f 92       	push	r1
 176:	cd b7       	in	r28, 0x3d	; 61
 178:	de b7       	in	r29, 0x3e	; 62
 17a:	9a 83       	std	Y+2, r25	; 0x02
 17c:	89 83       	std	Y+1, r24	; 0x01
 17e:	6b 83       	std	Y+3, r22	; 0x03
 180:	5d 83       	std	Y+5, r21	; 0x05
 182:	4c 83       	std	Y+4, r20	; 0x04
	static uint8 Local_u8_task_struct_index = NUM_ZERO;
	Task_struct[Local_u8_task_struct_index].Ready_Tasks_PTR = Added_Fun_Name ; /* Add the function name of the task will run to the struct */
 184:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 188:	28 2f       	mov	r18, r24
 18a:	30 e0       	ldi	r19, 0x00	; 0
 18c:	c9 01       	movw	r24, r18
 18e:	88 0f       	add	r24, r24
 190:	99 1f       	adc	r25, r25
 192:	88 0f       	add	r24, r24
 194:	99 1f       	adc	r25, r25
 196:	82 0f       	add	r24, r18
 198:	93 1f       	adc	r25, r19
 19a:	8a 59       	subi	r24, 0x9A	; 154
 19c:	9f 4f       	sbci	r25, 0xFF	; 255
 19e:	29 81       	ldd	r18, Y+1	; 0x01
 1a0:	3a 81       	ldd	r19, Y+2	; 0x02
 1a2:	fc 01       	movw	r30, r24
 1a4:	31 83       	std	Z+1, r19	; 0x01
 1a6:	20 83       	st	Z, r18
	Task_struct[Local_u8_task_struct_index].se_u8_task_priodicity = task_periodicity ; /* receive task periodicity from user */
 1a8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 1ac:	28 2f       	mov	r18, r24
 1ae:	30 e0       	ldi	r19, 0x00	; 0
 1b0:	4c 81       	ldd	r20, Y+4	; 0x04
 1b2:	c9 01       	movw	r24, r18
 1b4:	88 0f       	add	r24, r24
 1b6:	99 1f       	adc	r25, r25
 1b8:	88 0f       	add	r24, r24
 1ba:	99 1f       	adc	r25, r25
 1bc:	82 0f       	add	r24, r18
 1be:	93 1f       	adc	r25, r19
 1c0:	88 59       	subi	r24, 0x98	; 152
 1c2:	9f 4f       	sbci	r25, 0xFF	; 255
 1c4:	fc 01       	movw	r30, r24
 1c6:	40 83       	st	Z, r20
	Task_struct[Local_u8_task_struct_index].se_u8_rem_ticks_to_execute_task = task_periodicity ; /* init periodicity with tick */
 1c8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 1cc:	28 2f       	mov	r18, r24
 1ce:	30 e0       	ldi	r19, 0x00	; 0
 1d0:	4c 81       	ldd	r20, Y+4	; 0x04
 1d2:	c9 01       	movw	r24, r18
 1d4:	88 0f       	add	r24, r24
 1d6:	99 1f       	adc	r25, r25
 1d8:	88 0f       	add	r24, r24
 1da:	99 1f       	adc	r25, r25
 1dc:	82 0f       	add	r24, r18
 1de:	93 1f       	adc	r25, r19
 1e0:	87 59       	subi	r24, 0x97	; 151
 1e2:	9f 4f       	sbci	r25, 0xFF	; 255
 1e4:	fc 01       	movw	r30, r24
 1e6:	40 83       	st	Z, r20
	Task_struct[Local_u8_task_struct_index].se_u8_task_priority = fun_priority ; /* set the priority of the task */
 1e8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 1ec:	28 2f       	mov	r18, r24
 1ee:	30 e0       	ldi	r19, 0x00	; 0
 1f0:	c9 01       	movw	r24, r18
 1f2:	88 0f       	add	r24, r24
 1f4:	99 1f       	adc	r25, r25
 1f6:	88 0f       	add	r24, r24
 1f8:	99 1f       	adc	r25, r25
 1fa:	82 0f       	add	r24, r18
 1fc:	93 1f       	adc	r25, r19
 1fe:	86 59       	subi	r24, 0x96	; 150
 200:	9f 4f       	sbci	r25, 0xFF	; 255
 202:	2b 81       	ldd	r18, Y+3	; 0x03
 204:	fc 01       	movw	r30, r24
 206:	20 83       	st	Z, r18
	Local_u8_task_struct_index++ ;
 208:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__data_end>
 20c:	8f 5f       	subi	r24, 0xFF	; 255
 20e:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <__data_end>
}
 212:	00 00       	nop
 214:	0f 90       	pop	r0
 216:	0f 90       	pop	r0
 218:	0f 90       	pop	r0
 21a:	0f 90       	pop	r0
 21c:	0f 90       	pop	r0
 21e:	df 91       	pop	r29
 220:	cf 91       	pop	r28
 222:	08 95       	ret

00000224 <schedulerStart_according_periodicity_priority>:
					  
						
Function Return      : N/A

*******************************************************************************/
 void schedulerStart_according_periodicity_priority(){
 224:	cf 93       	push	r28
 226:	df 93       	push	r29
 228:	00 d0       	rcall	.+0      	; 0x22a <schedulerStart_according_periodicity_priority+0x6>
 22a:	00 d0       	rcall	.+0      	; 0x22c <schedulerStart_according_periodicity_priority+0x8>
 22c:	1f 92       	push	r1
 22e:	cd b7       	in	r28, 0x3d	; 61
 230:	de b7       	in	r29, 0x3e	; 62
	static uint8 Local_u8_task_counter = NUM_ZERO ;  /* Define counter to count the task ready to run */
	uint8 Local_u8_task_rem_time_counter ; /* Declare counter to loop on tasks to reduce the remaining time */
	uint8 Local_u8_arr_ready_task[TTC_MAX_TASKS_NUM] ; /* Declare array to save ready tasks to run */
	uint8 Local_u8_ready_tasks_index = NUM_ZERO ;
 232:	1a 82       	std	Y+2, r1	; 0x02
	
	
	for(Local_u8_task_rem_time_counter = NUM_ZERO ;Local_u8_task_rem_time_counter < TTC_MAX_TASKS_NUM;Local_u8_task_rem_time_counter++){
 234:	19 82       	std	Y+1, r1	; 0x01
 236:	5b c0       	rjmp	.+182    	; 0x2ee <schedulerStart_according_periodicity_priority+0xca>
		if(NULL != Task_struct[Local_u8_task_counter].Ready_Tasks_PTR){ /* In case of valid task added to the tasks array of structure */
 238:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <Local_u8_task_counter.1790>
 23c:	28 2f       	mov	r18, r24
 23e:	30 e0       	ldi	r19, 0x00	; 0
 240:	c9 01       	movw	r24, r18
 242:	88 0f       	add	r24, r24
 244:	99 1f       	adc	r25, r25
 246:	88 0f       	add	r24, r24
 248:	99 1f       	adc	r25, r25
 24a:	82 0f       	add	r24, r18
 24c:	93 1f       	adc	r25, r19
 24e:	8a 59       	subi	r24, 0x9A	; 154
 250:	9f 4f       	sbci	r25, 0xFF	; 255
 252:	fc 01       	movw	r30, r24
 254:	80 81       	ld	r24, Z
 256:	91 81       	ldd	r25, Z+1	; 0x01
 258:	89 2b       	or	r24, r25
 25a:	09 f4       	brne	.+2      	; 0x25e <schedulerStart_according_periodicity_priority+0x3a>
 25c:	45 c0       	rjmp	.+138    	; 0x2e8 <schedulerStart_according_periodicity_priority+0xc4>
			Task_struct[Local_u8_task_rem_time_counter].se_u8_rem_ticks_to_execute_task-- ; /* Decrease the remaining  time each tick for all tasks */
 25e:	89 81       	ldd	r24, Y+1	; 0x01
 260:	28 2f       	mov	r18, r24
 262:	30 e0       	ldi	r19, 0x00	; 0
 264:	c9 01       	movw	r24, r18
 266:	88 0f       	add	r24, r24
 268:	99 1f       	adc	r25, r25
 26a:	88 0f       	add	r24, r24
 26c:	99 1f       	adc	r25, r25
 26e:	82 0f       	add	r24, r18
 270:	93 1f       	adc	r25, r19
 272:	87 59       	subi	r24, 0x97	; 151
 274:	9f 4f       	sbci	r25, 0xFF	; 255
 276:	fc 01       	movw	r30, r24
 278:	80 81       	ld	r24, Z
 27a:	4f ef       	ldi	r20, 0xFF	; 255
 27c:	48 0f       	add	r20, r24
 27e:	c9 01       	movw	r24, r18
 280:	88 0f       	add	r24, r24
 282:	99 1f       	adc	r25, r25
 284:	88 0f       	add	r24, r24
 286:	99 1f       	adc	r25, r25
 288:	82 0f       	add	r24, r18
 28a:	93 1f       	adc	r25, r19
 28c:	87 59       	subi	r24, 0x97	; 151
 28e:	9f 4f       	sbci	r25, 0xFF	; 255
 290:	fc 01       	movw	r30, r24
 292:	40 83       	st	Z, r20
			/* Check tasks to detect which on ready to be executed => rem time = 0 */
			if(NUM_ZERO == Task_struct[Local_u8_task_rem_time_counter].se_u8_rem_ticks_to_execute_task){
 294:	89 81       	ldd	r24, Y+1	; 0x01
 296:	28 2f       	mov	r18, r24
 298:	30 e0       	ldi	r19, 0x00	; 0
 29a:	c9 01       	movw	r24, r18
 29c:	88 0f       	add	r24, r24
 29e:	99 1f       	adc	r25, r25
 2a0:	88 0f       	add	r24, r24
 2a2:	99 1f       	adc	r25, r25
 2a4:	82 0f       	add	r24, r18
 2a6:	93 1f       	adc	r25, r19
 2a8:	87 59       	subi	r24, 0x97	; 151
 2aa:	9f 4f       	sbci	r25, 0xFF	; 255
 2ac:	fc 01       	movw	r30, r24
 2ae:	80 81       	ld	r24, Z
 2b0:	88 23       	and	r24, r24
 2b2:	d1 f4       	brne	.+52     	; 0x2e8 <schedulerStart_according_periodicity_priority+0xc4>
				Local_u8_arr_ready_task[Local_u8_ready_tasks_index] = 	Task_struct[Local_u8_task_rem_time_counter].se_u8_task_priority ; /* save the ready tasks in the ready tasks array */
 2b4:	8a 81       	ldd	r24, Y+2	; 0x02
 2b6:	48 2f       	mov	r20, r24
 2b8:	50 e0       	ldi	r21, 0x00	; 0
 2ba:	89 81       	ldd	r24, Y+1	; 0x01
 2bc:	28 2f       	mov	r18, r24
 2be:	30 e0       	ldi	r19, 0x00	; 0
 2c0:	c9 01       	movw	r24, r18
 2c2:	88 0f       	add	r24, r24
 2c4:	99 1f       	adc	r25, r25
 2c6:	88 0f       	add	r24, r24
 2c8:	99 1f       	adc	r25, r25
 2ca:	82 0f       	add	r24, r18
 2cc:	93 1f       	adc	r25, r19
 2ce:	86 59       	subi	r24, 0x96	; 150
 2d0:	9f 4f       	sbci	r25, 0xFF	; 255
 2d2:	fc 01       	movw	r30, r24
 2d4:	20 81       	ld	r18, Z
 2d6:	ce 01       	movw	r24, r28
 2d8:	03 96       	adiw	r24, 0x03	; 3
 2da:	84 0f       	add	r24, r20
 2dc:	95 1f       	adc	r25, r21
 2de:	fc 01       	movw	r30, r24
 2e0:	20 83       	st	Z, r18
				Local_u8_ready_tasks_index++ ; /* increment array counter for ready tasks */
 2e2:	8a 81       	ldd	r24, Y+2	; 0x02
 2e4:	8f 5f       	subi	r24, 0xFF	; 255
 2e6:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Local_u8_task_rem_time_counter ; /* Declare counter to loop on tasks to reduce the remaining time */
	uint8 Local_u8_arr_ready_task[TTC_MAX_TASKS_NUM] ; /* Declare array to save ready tasks to run */
	uint8 Local_u8_ready_tasks_index = NUM_ZERO ;
	
	
	for(Local_u8_task_rem_time_counter = NUM_ZERO ;Local_u8_task_rem_time_counter < TTC_MAX_TASKS_NUM;Local_u8_task_rem_time_counter++){
 2e8:	89 81       	ldd	r24, Y+1	; 0x01
 2ea:	8f 5f       	subi	r24, 0xFF	; 255
 2ec:	89 83       	std	Y+1, r24	; 0x01
 2ee:	89 81       	ldd	r24, Y+1	; 0x01
 2f0:	83 30       	cpi	r24, 0x03	; 3
 2f2:	08 f4       	brcc	.+2      	; 0x2f6 <schedulerStart_according_periodicity_priority+0xd2>
 2f4:	a1 cf       	rjmp	.-190    	; 0x238 <schedulerStart_according_periodicity_priority+0x14>
				Local_u8_ready_tasks_index++ ; /* increment array counter for ready tasks */
			}
		}
	}
	/* sort the array to determine which task will run first */
	selectionSort(Local_u8_arr_ready_task,Local_u8_ready_tasks_index);
 2f6:	8a 81       	ldd	r24, Y+2	; 0x02
 2f8:	28 2f       	mov	r18, r24
 2fa:	30 e0       	ldi	r19, 0x00	; 0
 2fc:	ce 01       	movw	r24, r28
 2fe:	03 96       	adiw	r24, 0x03	; 3
 300:	b9 01       	movw	r22, r18
 302:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <selectionSort>
	/* Run the ready tasks */
	for(Local_u8_task_rem_time_counter = NUM_ZERO ;Local_u8_task_rem_time_counter < Local_u8_ready_tasks_index;Local_u8_task_rem_time_counter++){
 306:	19 82       	std	Y+1, r1	; 0x01
 308:	1d c0       	rjmp	.+58     	; 0x344 <schedulerStart_according_periodicity_priority+0x120>
		Task_struct[Local_u8_arr_ready_task[Local_u8_task_rem_time_counter]].Ready_Tasks_PTR(); /* call the function ready to run */
 30a:	89 81       	ldd	r24, Y+1	; 0x01
 30c:	88 2f       	mov	r24, r24
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	9e 01       	movw	r18, r28
 312:	2d 5f       	subi	r18, 0xFD	; 253
 314:	3f 4f       	sbci	r19, 0xFF	; 255
 316:	82 0f       	add	r24, r18
 318:	93 1f       	adc	r25, r19
 31a:	fc 01       	movw	r30, r24
 31c:	80 81       	ld	r24, Z
 31e:	28 2f       	mov	r18, r24
 320:	30 e0       	ldi	r19, 0x00	; 0
 322:	c9 01       	movw	r24, r18
 324:	88 0f       	add	r24, r24
 326:	99 1f       	adc	r25, r25
 328:	88 0f       	add	r24, r24
 32a:	99 1f       	adc	r25, r25
 32c:	82 0f       	add	r24, r18
 32e:	93 1f       	adc	r25, r19
 330:	8a 59       	subi	r24, 0x9A	; 154
 332:	9f 4f       	sbci	r25, 0xFF	; 255
 334:	fc 01       	movw	r30, r24
 336:	80 81       	ld	r24, Z
 338:	91 81       	ldd	r25, Z+1	; 0x01
 33a:	fc 01       	movw	r30, r24
 33c:	09 95       	icall
		}
	}
	/* sort the array to determine which task will run first */
	selectionSort(Local_u8_arr_ready_task,Local_u8_ready_tasks_index);
	/* Run the ready tasks */
	for(Local_u8_task_rem_time_counter = NUM_ZERO ;Local_u8_task_rem_time_counter < Local_u8_ready_tasks_index;Local_u8_task_rem_time_counter++){
 33e:	89 81       	ldd	r24, Y+1	; 0x01
 340:	8f 5f       	subi	r24, 0xFF	; 255
 342:	89 83       	std	Y+1, r24	; 0x01
 344:	99 81       	ldd	r25, Y+1	; 0x01
 346:	8a 81       	ldd	r24, Y+2	; 0x02
 348:	98 17       	cp	r25, r24
 34a:	f8 f2       	brcs	.-66     	; 0x30a <schedulerStart_according_periodicity_priority+0xe6>
		Task_struct[Local_u8_arr_ready_task[Local_u8_task_rem_time_counter]].Ready_Tasks_PTR(); /* call the function ready to run */
	}
	
	
}
 34c:	00 00       	nop
 34e:	0f 90       	pop	r0
 350:	0f 90       	pop	r0
 352:	0f 90       	pop	r0
 354:	0f 90       	pop	r0
 356:	0f 90       	pop	r0
 358:	df 91       	pop	r29
 35a:	cf 91       	pop	r28
 35c:	08 95       	ret

0000035e <DIO_SetPinDirection>:

Functions Parameters : PinDirection	 (Input or Output) , PinNum (number of the pin to write into it from 0 to 31)

Functions Return     : N/A
*****************************************************************************************************************************/
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection){
 35e:	cf 93       	push	r28
 360:	df 93       	push	r29
 362:	00 d0       	rcall	.+0      	; 0x364 <DIO_SetPinDirection+0x6>
 364:	cd b7       	in	r28, 0x3d	; 61
 366:	de b7       	in	r29, 0x3e	; 62
 368:	89 83       	std	Y+1, r24	; 0x01
 36a:	6a 83       	std	Y+2, r22	; 0x02
	switch(PinDirection){			/* check the direction of the pin wanted */
 36c:	8a 81       	ldd	r24, Y+2	; 0x02
 36e:	88 2f       	mov	r24, r24
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	00 97       	sbiw	r24, 0x00	; 0
 374:	21 f0       	breq	.+8      	; 0x37e <DIO_SetPinDirection+0x20>
 376:	01 97       	sbiw	r24, 0x01	; 1
 378:	09 f4       	brne	.+2      	; 0x37c <DIO_SetPinDirection+0x1e>
 37a:	7a c0       	rjmp	.+244    	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
				Set_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
			}
		break;
		default:
		break;
 37c:	ef c0       	rjmp	.+478    	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
Functions Return     : N/A
*****************************************************************************************************************************/
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection){
	switch(PinDirection){			/* check the direction of the pin wanted */
		case INPUT :				/* case input pin */
			if(PinNum >= PORTA_STARTING_PIN_NUM && PinNum <= PORTA_ENDING_PIN_NUM){		/* case porta */
 37e:	89 81       	ldd	r24, Y+1	; 0x01
 380:	88 30       	cpi	r24, 0x08	; 8
 382:	b0 f4       	brcc	.+44     	; 0x3b0 <DIO_SetPinDirection+0x52>
				Clear_Bit(DDR_A,PinNum);
 384:	8a e3       	ldi	r24, 0x3A	; 58
 386:	90 e0       	ldi	r25, 0x00	; 0
 388:	2a e3       	ldi	r18, 0x3A	; 58
 38a:	30 e0       	ldi	r19, 0x00	; 0
 38c:	f9 01       	movw	r30, r18
 38e:	20 81       	ld	r18, Z
 390:	62 2f       	mov	r22, r18
 392:	29 81       	ldd	r18, Y+1	; 0x01
 394:	42 2f       	mov	r20, r18
 396:	50 e0       	ldi	r21, 0x00	; 0
 398:	21 e0       	ldi	r18, 0x01	; 1
 39a:	30 e0       	ldi	r19, 0x00	; 0
 39c:	02 c0       	rjmp	.+4      	; 0x3a2 <DIO_SetPinDirection+0x44>
 39e:	22 0f       	add	r18, r18
 3a0:	33 1f       	adc	r19, r19
 3a2:	4a 95       	dec	r20
 3a4:	e2 f7       	brpl	.-8      	; 0x39e <DIO_SetPinDirection+0x40>
 3a6:	20 95       	com	r18
 3a8:	26 23       	and	r18, r22
 3aa:	fc 01       	movw	r30, r24
 3ac:	20 83       	st	Z, r18
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
				Clear_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
				Clear_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
			}
		break;
 3ae:	d3 c0       	rjmp	.+422    	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection){
	switch(PinDirection){			/* check the direction of the pin wanted */
		case INPUT :				/* case input pin */
			if(PinNum >= PORTA_STARTING_PIN_NUM && PinNum <= PORTA_ENDING_PIN_NUM){		/* case porta */
				Clear_Bit(DDR_A,PinNum);
			}else if(PinNum >= PORTB_STARTING_PIN_NUM && PinNum <= PORTB_ENDING_PIN_NUM){
 3b0:	89 81       	ldd	r24, Y+1	; 0x01
 3b2:	88 30       	cpi	r24, 0x08	; 8
 3b4:	e0 f0       	brcs	.+56     	; 0x3ee <DIO_SetPinDirection+0x90>
 3b6:	89 81       	ldd	r24, Y+1	; 0x01
 3b8:	80 31       	cpi	r24, 0x10	; 16
 3ba:	c8 f4       	brcc	.+50     	; 0x3ee <DIO_SetPinDirection+0x90>
				Clear_Bit(DDR_B,(PinNum - PORTB_STARTING_PIN_NUM));
 3bc:	87 e3       	ldi	r24, 0x37	; 55
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	27 e3       	ldi	r18, 0x37	; 55
 3c2:	30 e0       	ldi	r19, 0x00	; 0
 3c4:	f9 01       	movw	r30, r18
 3c6:	20 81       	ld	r18, Z
 3c8:	62 2f       	mov	r22, r18
 3ca:	29 81       	ldd	r18, Y+1	; 0x01
 3cc:	22 2f       	mov	r18, r18
 3ce:	30 e0       	ldi	r19, 0x00	; 0
 3d0:	a9 01       	movw	r20, r18
 3d2:	48 50       	subi	r20, 0x08	; 8
 3d4:	51 09       	sbc	r21, r1
 3d6:	21 e0       	ldi	r18, 0x01	; 1
 3d8:	30 e0       	ldi	r19, 0x00	; 0
 3da:	02 c0       	rjmp	.+4      	; 0x3e0 <DIO_SetPinDirection+0x82>
 3dc:	22 0f       	add	r18, r18
 3de:	33 1f       	adc	r19, r19
 3e0:	4a 95       	dec	r20
 3e2:	e2 f7       	brpl	.-8      	; 0x3dc <DIO_SetPinDirection+0x7e>
 3e4:	20 95       	com	r18
 3e6:	26 23       	and	r18, r22
 3e8:	fc 01       	movw	r30, r24
 3ea:	20 83       	st	Z, r18
 3ec:	40 c0       	rjmp	.+128    	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
 3ee:	89 81       	ldd	r24, Y+1	; 0x01
 3f0:	80 31       	cpi	r24, 0x10	; 16
 3f2:	e0 f0       	brcs	.+56     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 3f4:	89 81       	ldd	r24, Y+1	; 0x01
 3f6:	88 31       	cpi	r24, 0x18	; 24
 3f8:	c8 f4       	brcc	.+50     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
				Clear_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
 3fa:	84 e3       	ldi	r24, 0x34	; 52
 3fc:	90 e0       	ldi	r25, 0x00	; 0
 3fe:	24 e3       	ldi	r18, 0x34	; 52
 400:	30 e0       	ldi	r19, 0x00	; 0
 402:	f9 01       	movw	r30, r18
 404:	20 81       	ld	r18, Z
 406:	62 2f       	mov	r22, r18
 408:	29 81       	ldd	r18, Y+1	; 0x01
 40a:	22 2f       	mov	r18, r18
 40c:	30 e0       	ldi	r19, 0x00	; 0
 40e:	a9 01       	movw	r20, r18
 410:	40 51       	subi	r20, 0x10	; 16
 412:	51 09       	sbc	r21, r1
 414:	21 e0       	ldi	r18, 0x01	; 1
 416:	30 e0       	ldi	r19, 0x00	; 0
 418:	02 c0       	rjmp	.+4      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 41a:	22 0f       	add	r18, r18
 41c:	33 1f       	adc	r19, r19
 41e:	4a 95       	dec	r20
 420:	e2 f7       	brpl	.-8      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
 422:	20 95       	com	r18
 424:	26 23       	and	r18, r22
 426:	fc 01       	movw	r30, r24
 428:	20 83       	st	Z, r18
 42a:	21 c0       	rjmp	.+66     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
 42c:	89 81       	ldd	r24, Y+1	; 0x01
 42e:	88 31       	cpi	r24, 0x18	; 24
 430:	08 f4       	brcc	.+2      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
 432:	91 c0       	rjmp	.+290    	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
 434:	89 81       	ldd	r24, Y+1	; 0x01
 436:	80 32       	cpi	r24, 0x20	; 32
 438:	08 f0       	brcs	.+2      	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 43a:	8d c0       	rjmp	.+282    	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
				Clear_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
 43c:	81 e3       	ldi	r24, 0x31	; 49
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	21 e3       	ldi	r18, 0x31	; 49
 442:	30 e0       	ldi	r19, 0x00	; 0
 444:	f9 01       	movw	r30, r18
 446:	20 81       	ld	r18, Z
 448:	62 2f       	mov	r22, r18
 44a:	29 81       	ldd	r18, Y+1	; 0x01
 44c:	22 2f       	mov	r18, r18
 44e:	30 e0       	ldi	r19, 0x00	; 0
 450:	a9 01       	movw	r20, r18
 452:	48 51       	subi	r20, 0x18	; 24
 454:	51 09       	sbc	r21, r1
 456:	21 e0       	ldi	r18, 0x01	; 1
 458:	30 e0       	ldi	r19, 0x00	; 0
 45a:	02 c0       	rjmp	.+4      	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
 45c:	22 0f       	add	r18, r18
 45e:	33 1f       	adc	r19, r19
 460:	4a 95       	dec	r20
 462:	e2 f7       	brpl	.-8      	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
 464:	20 95       	com	r18
 466:	26 23       	and	r18, r22
 468:	fc 01       	movw	r30, r24
 46a:	20 83       	st	Z, r18
			}
		break;
 46c:	74 c0       	rjmp	.+232    	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
 46e:	73 c0       	rjmp	.+230    	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
		case OUTPUT :
			if(PinNum >= PORTA_STARTING_PIN_NUM && PinNum <= PORTA_ENDING_PIN_NUM){
 470:	89 81       	ldd	r24, Y+1	; 0x01
 472:	88 30       	cpi	r24, 0x08	; 8
 474:	a8 f4       	brcc	.+42     	; 0x4a0 <__LOCK_REGION_LENGTH__+0xa0>
				Set_Bit(DDR_A,PinNum);
 476:	8a e3       	ldi	r24, 0x3A	; 58
 478:	90 e0       	ldi	r25, 0x00	; 0
 47a:	2a e3       	ldi	r18, 0x3A	; 58
 47c:	30 e0       	ldi	r19, 0x00	; 0
 47e:	f9 01       	movw	r30, r18
 480:	20 81       	ld	r18, Z
 482:	62 2f       	mov	r22, r18
 484:	29 81       	ldd	r18, Y+1	; 0x01
 486:	42 2f       	mov	r20, r18
 488:	50 e0       	ldi	r21, 0x00	; 0
 48a:	21 e0       	ldi	r18, 0x01	; 1
 48c:	30 e0       	ldi	r19, 0x00	; 0
 48e:	02 c0       	rjmp	.+4      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
 490:	22 0f       	add	r18, r18
 492:	33 1f       	adc	r19, r19
 494:	4a 95       	dec	r20
 496:	e2 f7       	brpl	.-8      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
 498:	26 2b       	or	r18, r22
 49a:	fc 01       	movw	r30, r24
 49c:	20 83       	st	Z, r18
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
				Set_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
				Set_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
			}
		break;
 49e:	5d c0       	rjmp	.+186    	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
			}
		break;
		case OUTPUT :
			if(PinNum >= PORTA_STARTING_PIN_NUM && PinNum <= PORTA_ENDING_PIN_NUM){
				Set_Bit(DDR_A,PinNum);
			}else if(PinNum >= PORTB_STARTING_PIN_NUM && PinNum <= PORTB_ENDING_PIN_NUM){
 4a0:	89 81       	ldd	r24, Y+1	; 0x01
 4a2:	88 30       	cpi	r24, 0x08	; 8
 4a4:	d8 f0       	brcs	.+54     	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
 4a6:	89 81       	ldd	r24, Y+1	; 0x01
 4a8:	80 31       	cpi	r24, 0x10	; 16
 4aa:	c0 f4       	brcc	.+48     	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
				Set_Bit(DDR_B,(PinNum - PORTB_STARTING_PIN_NUM));
 4ac:	87 e3       	ldi	r24, 0x37	; 55
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	27 e3       	ldi	r18, 0x37	; 55
 4b2:	30 e0       	ldi	r19, 0x00	; 0
 4b4:	f9 01       	movw	r30, r18
 4b6:	20 81       	ld	r18, Z
 4b8:	62 2f       	mov	r22, r18
 4ba:	29 81       	ldd	r18, Y+1	; 0x01
 4bc:	22 2f       	mov	r18, r18
 4be:	30 e0       	ldi	r19, 0x00	; 0
 4c0:	a9 01       	movw	r20, r18
 4c2:	48 50       	subi	r20, 0x08	; 8
 4c4:	51 09       	sbc	r21, r1
 4c6:	21 e0       	ldi	r18, 0x01	; 1
 4c8:	30 e0       	ldi	r19, 0x00	; 0
 4ca:	02 c0       	rjmp	.+4      	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
 4cc:	22 0f       	add	r18, r18
 4ce:	33 1f       	adc	r19, r19
 4d0:	4a 95       	dec	r20
 4d2:	e2 f7       	brpl	.-8      	; 0x4cc <__LOCK_REGION_LENGTH__+0xcc>
 4d4:	26 2b       	or	r18, r22
 4d6:	fc 01       	movw	r30, r24
 4d8:	20 83       	st	Z, r18
 4da:	3c c0       	rjmp	.+120    	; 0x554 <__LOCK_REGION_LENGTH__+0x154>
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
 4dc:	89 81       	ldd	r24, Y+1	; 0x01
 4de:	80 31       	cpi	r24, 0x10	; 16
 4e0:	d8 f0       	brcs	.+54     	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
 4e2:	89 81       	ldd	r24, Y+1	; 0x01
 4e4:	88 31       	cpi	r24, 0x18	; 24
 4e6:	c0 f4       	brcc	.+48     	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
				Set_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
 4e8:	84 e3       	ldi	r24, 0x34	; 52
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	24 e3       	ldi	r18, 0x34	; 52
 4ee:	30 e0       	ldi	r19, 0x00	; 0
 4f0:	f9 01       	movw	r30, r18
 4f2:	20 81       	ld	r18, Z
 4f4:	62 2f       	mov	r22, r18
 4f6:	29 81       	ldd	r18, Y+1	; 0x01
 4f8:	22 2f       	mov	r18, r18
 4fa:	30 e0       	ldi	r19, 0x00	; 0
 4fc:	a9 01       	movw	r20, r18
 4fe:	40 51       	subi	r20, 0x10	; 16
 500:	51 09       	sbc	r21, r1
 502:	21 e0       	ldi	r18, 0x01	; 1
 504:	30 e0       	ldi	r19, 0x00	; 0
 506:	02 c0       	rjmp	.+4      	; 0x50c <__LOCK_REGION_LENGTH__+0x10c>
 508:	22 0f       	add	r18, r18
 50a:	33 1f       	adc	r19, r19
 50c:	4a 95       	dec	r20
 50e:	e2 f7       	brpl	.-8      	; 0x508 <__LOCK_REGION_LENGTH__+0x108>
 510:	26 2b       	or	r18, r22
 512:	fc 01       	movw	r30, r24
 514:	20 83       	st	Z, r18
 516:	1e c0       	rjmp	.+60     	; 0x554 <__LOCK_REGION_LENGTH__+0x154>
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
 518:	89 81       	ldd	r24, Y+1	; 0x01
 51a:	88 31       	cpi	r24, 0x18	; 24
 51c:	f0 f0       	brcs	.+60     	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
 51e:	89 81       	ldd	r24, Y+1	; 0x01
 520:	80 32       	cpi	r24, 0x20	; 32
 522:	d8 f4       	brcc	.+54     	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
				Set_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
 524:	81 e3       	ldi	r24, 0x31	; 49
 526:	90 e0       	ldi	r25, 0x00	; 0
 528:	21 e3       	ldi	r18, 0x31	; 49
 52a:	30 e0       	ldi	r19, 0x00	; 0
 52c:	f9 01       	movw	r30, r18
 52e:	20 81       	ld	r18, Z
 530:	62 2f       	mov	r22, r18
 532:	29 81       	ldd	r18, Y+1	; 0x01
 534:	22 2f       	mov	r18, r18
 536:	30 e0       	ldi	r19, 0x00	; 0
 538:	a9 01       	movw	r20, r18
 53a:	48 51       	subi	r20, 0x18	; 24
 53c:	51 09       	sbc	r21, r1
 53e:	21 e0       	ldi	r18, 0x01	; 1
 540:	30 e0       	ldi	r19, 0x00	; 0
 542:	02 c0       	rjmp	.+4      	; 0x548 <__LOCK_REGION_LENGTH__+0x148>
 544:	22 0f       	add	r18, r18
 546:	33 1f       	adc	r19, r19
 548:	4a 95       	dec	r20
 54a:	e2 f7       	brpl	.-8      	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
 54c:	26 2b       	or	r18, r22
 54e:	fc 01       	movw	r30, r24
 550:	20 83       	st	Z, r18
			}
		break;
 552:	03 c0       	rjmp	.+6      	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
 554:	02 c0       	rjmp	.+4      	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
				Clear_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
				Clear_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
			}
		break;
 556:	00 00       	nop
 558:	01 c0       	rjmp	.+2      	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
			}else if(PinNum >= PORTC_STARTING_PIN_NUM && PinNum <= PORTC_ENDING_PIN_NUM){
				Set_Bit(DDR_C,(PinNum - PORTC_STARTING_PIN_NUM));
			}else if(PinNum >= PORTD_STARTING_PIN_NUM && PinNum <= PORTD_ENDING_PIN_NUM){
				Set_Bit(DDR_D,(PinNum - PORTD_STARTING_PIN_NUM));
			}
		break;
 55a:	00 00       	nop
		default:
		break;
	}
}
 55c:	00 00       	nop
 55e:	0f 90       	pop	r0
 560:	0f 90       	pop	r0
 562:	df 91       	pop	r29
 564:	cf 91       	pop	r28
 566:	08 95       	ret

00000568 <main>:
#include "HAL/headers/DC_Motor.h"
#include "APP/TTC Schedular/TTC_Headers/TTC_Schedular.h"
#include "APP/TTC Schedular/TTC_Headers/Tasks.h"

int main(void)
{
 568:	cf 93       	push	r28
 56a:	df 93       	push	r29
 56c:	cd b7       	in	r28, 0x3d	; 61
 56e:	de b7       	in	r29, 0x3e	; 62
	sei();
 570:	78 94       	sei
	Tasks_init();
 572:	0e 94 5c 00 	call	0xb8	; 0xb8 <Tasks_init>
	Schedular_init(Task_BLINK_LED1,1,1000);
 576:	48 ee       	ldi	r20, 0xE8	; 232
 578:	53 e0       	ldi	r21, 0x03	; 3
 57a:	61 e0       	ldi	r22, 0x01	; 1
 57c:	84 e7       	ldi	r24, 0x74	; 116
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	0e 94 b6 00 	call	0x16c	; 0x16c <Schedular_init>
	Schedular_init(Task_BLINK_LED2,2,2000);
 584:	40 ed       	ldi	r20, 0xD0	; 208
 586:	57 e0       	ldi	r21, 0x07	; 7
 588:	62 e0       	ldi	r22, 0x02	; 2
 58a:	8a e8       	ldi	r24, 0x8A	; 138
 58c:	90 e0       	ldi	r25, 0x00	; 0
 58e:	0e 94 b6 00 	call	0x16c	; 0x16c <Schedular_init>
	Schedular_init(Task_BLINK_LED3,0,3000);
 592:	48 eb       	ldi	r20, 0xB8	; 184
 594:	5b e0       	ldi	r21, 0x0B	; 11
 596:	60 e0       	ldi	r22, 0x00	; 0
 598:	80 ea       	ldi	r24, 0xA0	; 160
 59a:	90 e0       	ldi	r25, 0x00	; 0
 59c:	0e 94 b6 00 	call	0x16c	; 0x16c <Schedular_init>
    while(1) 
    {
		schedulerStart_according_periodicity_priority();
 5a0:	0e 94 12 01 	call	0x224	; 0x224 <schedulerStart_according_periodicity_priority>
			
	}
 5a4:	fd cf       	rjmp	.-6      	; 0x5a0 <main+0x38>

000005a6 <selectionSort>:
 ********************************************************************************/
#include "../headers/Selection_Sort.h"


void selectionSort(int arr[], int arr_size)
{
 5a6:	cf 93       	push	r28
 5a8:	df 93       	push	r29
 5aa:	cd b7       	in	r28, 0x3d	; 61
 5ac:	de b7       	in	r29, 0x3e	; 62
 5ae:	2a 97       	sbiw	r28, 0x0a	; 10
 5b0:	0f b6       	in	r0, 0x3f	; 63
 5b2:	f8 94       	cli
 5b4:	de bf       	out	0x3e, r29	; 62
 5b6:	0f be       	out	0x3f, r0	; 63
 5b8:	cd bf       	out	0x3d, r28	; 61
 5ba:	98 87       	std	Y+8, r25	; 0x08
 5bc:	8f 83       	std	Y+7, r24	; 0x07
 5be:	7a 87       	std	Y+10, r23	; 0x0a
 5c0:	69 87       	std	Y+9, r22	; 0x09
	/* Your code goes here */
	int arr_counter , arr_counter2 , temp;
		for(arr_counter = 0 ; arr_counter < arr_size ; arr_counter++){
 5c2:	1a 82       	std	Y+2, r1	; 0x02
 5c4:	19 82       	std	Y+1, r1	; 0x01
 5c6:	60 c0       	rjmp	.+192    	; 0x688 <selectionSort+0xe2>
			for(arr_counter2 = arr_counter ; arr_counter2 < arr_size;arr_counter2++){
 5c8:	89 81       	ldd	r24, Y+1	; 0x01
 5ca:	9a 81       	ldd	r25, Y+2	; 0x02
 5cc:	9c 83       	std	Y+4, r25	; 0x04
 5ce:	8b 83       	std	Y+3, r24	; 0x03
 5d0:	4e c0       	rjmp	.+156    	; 0x66e <selectionSort+0xc8>
				if(arr[arr_counter] > arr[arr_counter2]){
 5d2:	89 81       	ldd	r24, Y+1	; 0x01
 5d4:	9a 81       	ldd	r25, Y+2	; 0x02
 5d6:	88 0f       	add	r24, r24
 5d8:	99 1f       	adc	r25, r25
 5da:	2f 81       	ldd	r18, Y+7	; 0x07
 5dc:	38 85       	ldd	r19, Y+8	; 0x08
 5de:	82 0f       	add	r24, r18
 5e0:	93 1f       	adc	r25, r19
 5e2:	fc 01       	movw	r30, r24
 5e4:	20 81       	ld	r18, Z
 5e6:	31 81       	ldd	r19, Z+1	; 0x01
 5e8:	8b 81       	ldd	r24, Y+3	; 0x03
 5ea:	9c 81       	ldd	r25, Y+4	; 0x04
 5ec:	88 0f       	add	r24, r24
 5ee:	99 1f       	adc	r25, r25
 5f0:	4f 81       	ldd	r20, Y+7	; 0x07
 5f2:	58 85       	ldd	r21, Y+8	; 0x08
 5f4:	84 0f       	add	r24, r20
 5f6:	95 1f       	adc	r25, r21
 5f8:	fc 01       	movw	r30, r24
 5fa:	80 81       	ld	r24, Z
 5fc:	91 81       	ldd	r25, Z+1	; 0x01
 5fe:	82 17       	cp	r24, r18
 600:	93 07       	cpc	r25, r19
 602:	84 f5       	brge	.+96     	; 0x664 <selectionSort+0xbe>
					temp = arr[arr_counter];
 604:	89 81       	ldd	r24, Y+1	; 0x01
 606:	9a 81       	ldd	r25, Y+2	; 0x02
 608:	88 0f       	add	r24, r24
 60a:	99 1f       	adc	r25, r25
 60c:	2f 81       	ldd	r18, Y+7	; 0x07
 60e:	38 85       	ldd	r19, Y+8	; 0x08
 610:	82 0f       	add	r24, r18
 612:	93 1f       	adc	r25, r19
 614:	fc 01       	movw	r30, r24
 616:	80 81       	ld	r24, Z
 618:	91 81       	ldd	r25, Z+1	; 0x01
 61a:	9e 83       	std	Y+6, r25	; 0x06
 61c:	8d 83       	std	Y+5, r24	; 0x05
					arr[arr_counter] = arr[arr_counter2];
 61e:	89 81       	ldd	r24, Y+1	; 0x01
 620:	9a 81       	ldd	r25, Y+2	; 0x02
 622:	88 0f       	add	r24, r24
 624:	99 1f       	adc	r25, r25
 626:	2f 81       	ldd	r18, Y+7	; 0x07
 628:	38 85       	ldd	r19, Y+8	; 0x08
 62a:	82 0f       	add	r24, r18
 62c:	93 1f       	adc	r25, r19
 62e:	2b 81       	ldd	r18, Y+3	; 0x03
 630:	3c 81       	ldd	r19, Y+4	; 0x04
 632:	22 0f       	add	r18, r18
 634:	33 1f       	adc	r19, r19
 636:	4f 81       	ldd	r20, Y+7	; 0x07
 638:	58 85       	ldd	r21, Y+8	; 0x08
 63a:	24 0f       	add	r18, r20
 63c:	35 1f       	adc	r19, r21
 63e:	f9 01       	movw	r30, r18
 640:	20 81       	ld	r18, Z
 642:	31 81       	ldd	r19, Z+1	; 0x01
 644:	fc 01       	movw	r30, r24
 646:	31 83       	std	Z+1, r19	; 0x01
 648:	20 83       	st	Z, r18
					arr[arr_counter2] = temp ;
 64a:	8b 81       	ldd	r24, Y+3	; 0x03
 64c:	9c 81       	ldd	r25, Y+4	; 0x04
 64e:	88 0f       	add	r24, r24
 650:	99 1f       	adc	r25, r25
 652:	2f 81       	ldd	r18, Y+7	; 0x07
 654:	38 85       	ldd	r19, Y+8	; 0x08
 656:	82 0f       	add	r24, r18
 658:	93 1f       	adc	r25, r19
 65a:	2d 81       	ldd	r18, Y+5	; 0x05
 65c:	3e 81       	ldd	r19, Y+6	; 0x06
 65e:	fc 01       	movw	r30, r24
 660:	31 83       	std	Z+1, r19	; 0x01
 662:	20 83       	st	Z, r18
void selectionSort(int arr[], int arr_size)
{
	/* Your code goes here */
	int arr_counter , arr_counter2 , temp;
		for(arr_counter = 0 ; arr_counter < arr_size ; arr_counter++){
			for(arr_counter2 = arr_counter ; arr_counter2 < arr_size;arr_counter2++){
 664:	8b 81       	ldd	r24, Y+3	; 0x03
 666:	9c 81       	ldd	r25, Y+4	; 0x04
 668:	01 96       	adiw	r24, 0x01	; 1
 66a:	9c 83       	std	Y+4, r25	; 0x04
 66c:	8b 83       	std	Y+3, r24	; 0x03
 66e:	2b 81       	ldd	r18, Y+3	; 0x03
 670:	3c 81       	ldd	r19, Y+4	; 0x04
 672:	89 85       	ldd	r24, Y+9	; 0x09
 674:	9a 85       	ldd	r25, Y+10	; 0x0a
 676:	28 17       	cp	r18, r24
 678:	39 07       	cpc	r19, r25
 67a:	0c f4       	brge	.+2      	; 0x67e <selectionSort+0xd8>
 67c:	aa cf       	rjmp	.-172    	; 0x5d2 <selectionSort+0x2c>

void selectionSort(int arr[], int arr_size)
{
	/* Your code goes here */
	int arr_counter , arr_counter2 , temp;
		for(arr_counter = 0 ; arr_counter < arr_size ; arr_counter++){
 67e:	89 81       	ldd	r24, Y+1	; 0x01
 680:	9a 81       	ldd	r25, Y+2	; 0x02
 682:	01 96       	adiw	r24, 0x01	; 1
 684:	9a 83       	std	Y+2, r25	; 0x02
 686:	89 83       	std	Y+1, r24	; 0x01
 688:	29 81       	ldd	r18, Y+1	; 0x01
 68a:	3a 81       	ldd	r19, Y+2	; 0x02
 68c:	89 85       	ldd	r24, Y+9	; 0x09
 68e:	9a 85       	ldd	r25, Y+10	; 0x0a
 690:	28 17       	cp	r18, r24
 692:	39 07       	cpc	r19, r25
 694:	0c f4       	brge	.+2      	; 0x698 <selectionSort+0xf2>
 696:	98 cf       	rjmp	.-208    	; 0x5c8 <selectionSort+0x22>
					arr[arr_counter] = arr[arr_counter2];
					arr[arr_counter2] = temp ;
				}
		}
	}
}
 698:	00 00       	nop
 69a:	2a 96       	adiw	r28, 0x0a	; 10
 69c:	0f b6       	in	r0, 0x3f	; 63
 69e:	f8 94       	cli
 6a0:	de bf       	out	0x3e, r29	; 62
 6a2:	0f be       	out	0x3f, r0	; 63
 6a4:	cd bf       	out	0x3d, r28	; 61
 6a6:	df 91       	pop	r29
 6a8:	cf 91       	pop	r28
 6aa:	08 95       	ret

000006ac <__vector_10>:
	Clear_Bit(TCCR0,5);

	
	TCNT0 = NUM_ZERO ;           
	
}
 6ac:	1f 92       	push	r1
 6ae:	0f 92       	push	r0
 6b0:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 6b4:	0f 92       	push	r0
 6b6:	11 24       	eor	r1, r1
 6b8:	2f 93       	push	r18
 6ba:	3f 93       	push	r19
 6bc:	4f 93       	push	r20
 6be:	5f 93       	push	r21
 6c0:	6f 93       	push	r22
 6c2:	7f 93       	push	r23
 6c4:	8f 93       	push	r24
 6c6:	9f 93       	push	r25
 6c8:	af 93       	push	r26
 6ca:	bf 93       	push	r27
 6cc:	ef 93       	push	r30
 6ce:	ff 93       	push	r31
 6d0:	cf 93       	push	r28
 6d2:	df 93       	push	r29
 6d4:	cd b7       	in	r28, 0x3d	; 61
 6d6:	de b7       	in	r29, 0x3e	; 62
 6d8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <Call_Back_Notification>
 6dc:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <Call_Back_Notification+0x1>
 6e0:	fc 01       	movw	r30, r24
 6e2:	09 95       	icall
 6e4:	00 00       	nop
 6e6:	df 91       	pop	r29
 6e8:	cf 91       	pop	r28
 6ea:	ff 91       	pop	r31
 6ec:	ef 91       	pop	r30
 6ee:	bf 91       	pop	r27
 6f0:	af 91       	pop	r26
 6f2:	9f 91       	pop	r25
 6f4:	8f 91       	pop	r24
 6f6:	7f 91       	pop	r23
 6f8:	6f 91       	pop	r22
 6fa:	5f 91       	pop	r21
 6fc:	4f 91       	pop	r20
 6fe:	3f 91       	pop	r19
 700:	2f 91       	pop	r18
 702:	0f 90       	pop	r0
 704:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 708:	0f 90       	pop	r0
 70a:	1f 90       	pop	r1
 70c:	18 95       	reti

0000070e <Set_Call_Back_Flag>:
 70e:	cf 93       	push	r28
 710:	df 93       	push	r29
 712:	cd b7       	in	r28, 0x3d	; 61
 714:	de b7       	in	r29, 0x3e	; 62
 716:	81 e0       	ldi	r24, 0x01	; 1
 718:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <Call_Back_Flag>
 71c:	00 00       	nop
 71e:	df 91       	pop	r29
 720:	cf 91       	pop	r28
 722:	08 95       	ret

00000724 <Set_Call_Back>:
 724:	cf 93       	push	r28
 726:	df 93       	push	r29
 728:	cd b7       	in	r28, 0x3d	; 61
 72a:	de b7       	in	r29, 0x3e	; 62
 72c:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <timer0_ticks>
 730:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <timer0_ticks+0x1>
 734:	01 96       	adiw	r24, 0x01	; 1
 736:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <timer0_ticks+0x1>
 73a:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <timer0_ticks>
 73e:	0e 94 87 03 	call	0x70e	; 0x70e <Set_Call_Back_Flag>
 742:	00 00       	nop
 744:	df 91       	pop	r29
 746:	cf 91       	pop	r28
 748:	08 95       	ret

0000074a <TIMER0_PRE_COMPILE_CONFIGURATIONS>:
 74a:	cf 93       	push	r28
 74c:	df 93       	push	r29
 74e:	cd b7       	in	r28, 0x3d	; 61
 750:	de b7       	in	r29, 0x3e	; 62
 752:	83 e5       	ldi	r24, 0x53	; 83
 754:	90 e0       	ldi	r25, 0x00	; 0
 756:	23 e5       	ldi	r18, 0x53	; 83
 758:	30 e0       	ldi	r19, 0x00	; 0
 75a:	f9 01       	movw	r30, r18
 75c:	20 81       	ld	r18, Z
 75e:	21 60       	ori	r18, 0x01	; 1
 760:	fc 01       	movw	r30, r24
 762:	20 83       	st	Z, r18
 764:	83 e5       	ldi	r24, 0x53	; 83
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	23 e5       	ldi	r18, 0x53	; 83
 76a:	30 e0       	ldi	r19, 0x00	; 0
 76c:	f9 01       	movw	r30, r18
 76e:	20 81       	ld	r18, Z
 770:	22 60       	ori	r18, 0x02	; 2
 772:	fc 01       	movw	r30, r24
 774:	20 83       	st	Z, r18
 776:	83 e5       	ldi	r24, 0x53	; 83
 778:	90 e0       	ldi	r25, 0x00	; 0
 77a:	23 e5       	ldi	r18, 0x53	; 83
 77c:	30 e0       	ldi	r19, 0x00	; 0
 77e:	f9 01       	movw	r30, r18
 780:	20 81       	ld	r18, Z
 782:	2b 7f       	andi	r18, 0xFB	; 251
 784:	fc 01       	movw	r30, r24
 786:	20 83       	st	Z, r18
 788:	00 00       	nop
 78a:	df 91       	pop	r29
 78c:	cf 91       	pop	r28
 78e:	08 95       	ret

00000790 <TIMER0_OCR_init>:

Function Parameters  : no_of_ticks : number of ticks before clearing the output compare pin 

Function Return      : N/A
************************************************************************************************/
void TIMER0_OCR_init(uint8 no_of_ticks){
 790:	cf 93       	push	r28
 792:	df 93       	push	r29
 794:	1f 92       	push	r1
 796:	cd b7       	in	r28, 0x3d	; 61
 798:	de b7       	in	r29, 0x3e	; 62
 79a:	89 83       	std	Y+1, r24	; 0x01
		TIMER0_PRE_COMPILE_CONFIGURATIONS();
 79c:	0e 94 a5 03 	call	0x74a	; 0x74a <TIMER0_PRE_COMPILE_CONFIGURATIONS>
		DIO_SetPinDirection(TIMER0_OCR_PIN_NUM,OUTPUT); /* make the compare mode pin as output pin */
 7a0:	61 e0       	ldi	r22, 0x01	; 1
 7a2:	8b e0       	ldi	r24, 0x0B	; 11
 7a4:	0e 94 af 01 	call	0x35e	; 0x35e <DIO_SetPinDirection>
	
		Set_Bit(TCCR0,7);   /* NON PWM MODE */
 7a8:	83 e5       	ldi	r24, 0x53	; 83
 7aa:	90 e0       	ldi	r25, 0x00	; 0
 7ac:	23 e5       	ldi	r18, 0x53	; 83
 7ae:	30 e0       	ldi	r19, 0x00	; 0
 7b0:	f9 01       	movw	r30, r18
 7b2:	20 81       	ld	r18, Z
 7b4:	20 68       	ori	r18, 0x80	; 128
 7b6:	fc 01       	movw	r30, r24
 7b8:	20 83       	st	Z, r18
		Clear_Bit(TCCR0,6); /* OCR Mode     */
 7ba:	83 e5       	ldi	r24, 0x53	; 83
 7bc:	90 e0       	ldi	r25, 0x00	; 0
 7be:	23 e5       	ldi	r18, 0x53	; 83
 7c0:	30 e0       	ldi	r19, 0x00	; 0
 7c2:	f9 01       	movw	r30, r18
 7c4:	20 81       	ld	r18, Z
 7c6:	2f 7b       	andi	r18, 0xBF	; 191
 7c8:	fc 01       	movw	r30, r24
 7ca:	20 83       	st	Z, r18
		Set_Bit(TCCR0,3);
 7cc:	83 e5       	ldi	r24, 0x53	; 83
 7ce:	90 e0       	ldi	r25, 0x00	; 0
 7d0:	23 e5       	ldi	r18, 0x53	; 83
 7d2:	30 e0       	ldi	r19, 0x00	; 0
 7d4:	f9 01       	movw	r30, r18
 7d6:	20 81       	ld	r18, Z
 7d8:	28 60       	ori	r18, 0x08	; 8
 7da:	fc 01       	movw	r30, r24
 7dc:	20 83       	st	Z, r18
		Clear_Bit(TCCR0,4);	/* Clear output compare pin in compare match */
 7de:	83 e5       	ldi	r24, 0x53	; 83
 7e0:	90 e0       	ldi	r25, 0x00	; 0
 7e2:	23 e5       	ldi	r18, 0x53	; 83
 7e4:	30 e0       	ldi	r19, 0x00	; 0
 7e6:	f9 01       	movw	r30, r18
 7e8:	20 81       	ld	r18, Z
 7ea:	2f 7e       	andi	r18, 0xEF	; 239
 7ec:	fc 01       	movw	r30, r24
 7ee:	20 83       	st	Z, r18
 		Set_Bit(TCCR0,5);
 7f0:	83 e5       	ldi	r24, 0x53	; 83
 7f2:	90 e0       	ldi	r25, 0x00	; 0
 7f4:	23 e5       	ldi	r18, 0x53	; 83
 7f6:	30 e0       	ldi	r19, 0x00	; 0
 7f8:	f9 01       	movw	r30, r18
 7fa:	20 81       	ld	r18, Z
 7fc:	20 62       	ori	r18, 0x20	; 32
 7fe:	fc 01       	movw	r30, r24
 800:	20 83       	st	Z, r18
	 
	 #ifdef TIMER0_OCR_INTERRUPTS
		Set_Bit(TIMSK,1);
 802:	89 e5       	ldi	r24, 0x59	; 89
 804:	90 e0       	ldi	r25, 0x00	; 0
 806:	29 e5       	ldi	r18, 0x59	; 89
 808:	30 e0       	ldi	r19, 0x00	; 0
 80a:	f9 01       	movw	r30, r18
 80c:	20 81       	ld	r18, Z
 80e:	22 60       	ori	r18, 0x02	; 2
 810:	fc 01       	movw	r30, r24
 812:	20 83       	st	Z, r18
	 
	 #ifdef TIMER1_OVF_INTERRUPTS
		Set_Bit(TIMSK,0);
	 #endif
	
	TCNT0 = NUM_ZERO ;
 814:	82 e5       	ldi	r24, 0x52	; 82
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	fc 01       	movw	r30, r24
 81a:	10 82       	st	Z, r1
	OCR0  = no_of_ticks ;
 81c:	8c e5       	ldi	r24, 0x5C	; 92
 81e:	90 e0       	ldi	r25, 0x00	; 0
 820:	29 81       	ldd	r18, Y+1	; 0x01
 822:	fc 01       	movw	r30, r24
 824:	20 83       	st	Z, r18
}
 826:	00 00       	nop
 828:	0f 90       	pop	r0
 82a:	df 91       	pop	r29
 82c:	cf 91       	pop	r28
 82e:	08 95       	ret

00000830 <_exit>:
 830:	f8 94       	cli

00000832 <__stop_program>:
 832:	ff cf       	rjmp	.-2      	; 0x832 <__stop_program>
